}
if (createplot) {
par(mar=c(1,1,1,1) )
if (is.null(displayname)) {
legtitle<-paste("Basin upstream of",featureID)
}
else {
legtitle<-paste("Basin upstream of",displayname)
}
plot(catchment.shape,border="red",ylim=c(bbox(basin.shape)[2,1]*.999,bbox(basin.shape)[2,2]))
box()
plot(basin.shape,border="orange",lwd=3,cex=3,add=T)
plot(stream.line,col="blue",add=T)
legend("bottomright",
legend = c("User-defined basin", "NHDplus Catchments", "NHDplus Flowlines"),
title = legtitle, cex=0.9,y.intersp = 0.9,
inset = .05,fill=c("orange","red","blue"))
}
}
} #end getBasinfromComID
getBasinfromLatLong<-function(lat,long,writefile=TRUE,createplot=TRUE) {
#create spatialpoint object from coordinates (coordinates are listed in the order long, lat)
point<-SpatialPoints(matrix(data=c(long,lat),ncol=2,byrow=T), proj4string=CRS(proj4.NHD))
#get catchment that contains the point
featureID<-over(point,NHDCatch.shape)$FEATUREID
#testing only print/plot
printtotest(paste0("feature ",featureID))
#   plottotest(NHDCatch.shape[NHDCatch.shape$FEATUREID == featureID,])
#   plottotest(point,add=T)
#files will be saved in a folder named by the coordinates provided
coordinates.string<-paste0("coords",as.character(round(lat,4)),as.character(round(long,4)))
coordinates.display<-paste0(  "Coordinates ", as.character(round(lat,4)), " , ", as.character(round(long,4))  )
#call previous function to find basin from the NHDplus flowline or catchment feature
getBasinfromComID(featureID,displayname=coordinates.display,writefile=writefile,createplot=createplot,coordinates.string=coordinates.string)
plot(point,add=T)
} #end basinfromlatlong function
getwd()
getBasinfromComID(6780817,writefile=T,createplot=F,displayname="West Brook") #i.e. 6780817
getBasinfromComID(6781011,writefile=T,createplot=F)
getBasinfromComID(6781079,writefile=T,createplot=F)
getBasinfromComID(6778605,writefile=T,createplot=F)
getBasinfromComID(6710265,writefile=T,createplot=F)
getBasinfromComID(6780763,writefile=T,createplot=F)
rm(list=c"plusdata")
rm(list=c("plusdata"))
getwd()
setwd(paste0(basedir,"/SpatialData/RData_SpatialDataFrames"))
save(NEFlow.line, file = "NEFlowline.RData")
bkup<-NEFlow.line
rm(list=c("NEFlow.line"))
plot(NEFlow.line)
NEFlow.line<-load(file="NEFlowline.RData")
plot(NEFlow.line)
NEFlow.line<-bkup
plot(NEFlow.line)
NHDFlow.line<-NEFlow.line
NHDCatch.shape<-NECatch.shape
str(NHDCatch.shape)
names(NHDCatch.shape@data)
segments
is.null(commandArgs())
commandArgs()
getBasinfromComID<-function(featureID,dirname,output_type="kml") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
if (file.exists(paste0(dirname,"/",featureID)))
return(TRUE)
### creates shapefiles and kml files of basin outline and streams & catchments it contains
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] >= 6) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] == 1) {
message("Please choose a larger stream or tributary")
return(NULL)
}
#else {
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
#collect all stream segments in upstream network
stream.line<-NHDFlow.line[NHDFlow.line$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#turn outline into spatial dataframe again to enable output as shapefile/kml
row.names(basin.shape)<-"rows"
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartingFeatureID=featureID,row.names=row.names(basin.shape)))
#export basin outline
setwd(dirname)
write(segments, file = "COMID.txt", ncolumns = 1, sep = "")
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "UserDefinedBasin.kml", layer="UserDefinedBasin", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
# I could change the code to pass the spatialpoint to this function,
# turn it into a spatialpointdataframe, and save it as a shape or kml file
# Would that be useful?
}
if (output_type=="shapefil" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="UserDefinedBasin", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
return(TRUE)
#}
} #end getBasinfromComID
getBasinfromLatLong<-function(lat,long,dirname,output_type="kml") {
#create spatialpoint object from coordinates (coordinates are listed in the order long, lat)
point<-SpatialPoints(matrix(data=c(long,lat),ncol=2,byrow=T), proj4string=CRS(proj4.NHD))
#get catchment that contains the point
featureID<-over(point,NHDCatch.shape)$FEATUREID
#call previous function to find basin from the NHDplus flowline or catchment feature
getBasinfromComID(featureID,dirname=dirname,output_type=output_type)
}
names(NHDFlow.line@data)
names(plusflow)
plusflow$FROMHYDSEQ[1:10]
names(plusflowlineVAA)
plusflowlineVAA[1:5,]
plusflow[1:5,]
NHDFlow.line@data[1:5,]
test<-NHDCatch.shape[NHDCatch.shape$FeatureID %in% "6780705 6780731 6780741 6780751 6780763 6780769 6780771 6780775 6780789 6780791 6780817 6781995 6782003",]
seg<-grep(" ",",","6780705 6780731 6780741 6780751 6780763 6780769 6780771 6780775 6780789 6780791 6780817 6781995 6782003")
seg
as.string(seg)
as.character(seg)
seg<-gsub(" ",",","6780705 6780731 6780741 6780751 6780763 6780769 6780771 6780775 6780789 6780791 6780817 6781995 6782003")
seg
as.vector(seg)
as.numeric(seg)
seg<-c(6780705,6780731,6780741,6780751,6780763,6780769,6780771,6780775,6780789,6780791,6780817,6781995,6782003)
seg
seg[2]
test<-NHDCatch.shape[NHDCatch.shape$FeatureID %in% seg,]
names(NHDCatch.shape)
test<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
test
test$FEATUREID
area<-sum(test$AreaSqKm)
area
names(test)
area<-sum(test$AreaSqKM)
area
test$AreaSqKM
cumarea<-read.dbf("CumulativeArea.dbf")
setwd("C:\ALR\SpatialData\NHDplus\NHDPlusV21_NE_01_NHDPlusAttributes_01\NHDPlusNE\NHDPlus01\NHDPlusAttributes")
cumarea<-read.dbf("CumulativeArea.dbf")
setwd("C:/ALR/SpatialData/NHDplus/NHDPlusV21_NE_01_NHDPlusAttributes_01/NHDPlusNE/NHDPlus01/NHDPlusAttributes")
cumarea<-read.dbf("CumulativeArea.dbf")
names(cumarea)
cumarea[ComID==6780817]
cumarea[cumarea$ComID==6780817]
cumarea[cumarea$ComID==6780817,]
class(test)
plot(test)
gCentroid(test)
basin.shape<-test
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartingFeatureID=featureID,row.names=row.names(basin.shape)))
featureID<-6780817
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartingFeatureID=featureID,row.names=row.names(basin.shape)))
row.names(basin.shape)
row.names(basin.shape)<-"rows"
coord<-gCentroid(basin.shape)
coord
spframe<-SpatialPointsDataFrame(coord,FeatureID=featureID)
spframe<-SpatialPointsDataFrame(coord,data=c(FeatureID=featureID))
basin.shape<-test
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL))
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=list(StartFID=featureID))
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=matrix(data =featureID, nrow = 1, ncol = 1))
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=row.names(basin.shape)))
row.names(basin.shape)<-NULL
basin.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID==featureID]
basin.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID==featureID,]
row.names(basin.shape)<-NULL
row.names(basin.shape)<-"rows"
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=row.names(basin.shape)))
basin.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID==featureID,]
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=row.names(basin.shape)))
basin.shape@data
basin.shape
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID==featureID,]
basin<-gUnaryUnion(catchments)
plot(basin)
plot(catchments)
plot(catchments)
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin<-gUnaryUnion(catchments)
plot(catchments)
plot(basin)
basin.shape<-basin
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=row.names(basin.shape)))
basin.shape@data
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL))
basin.shape@data
basin.shape<-basin
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL))
basin.shape@data
basin.shape
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
class(centroid)
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
class(centroid)
class(basin.shape)
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL))
class(basin.shape)
basin.shape@data
centroid<-SpatialPointsDataFrame(centroid,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
class(centroid)
centroid@data
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
class(basin.shape)
class(centroid)
class(catchments)
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE,proj4string=CRS(,match.ID=FALSE))
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE,proj4string=CRS(proj4.NHD))
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
attributes(centroid)
attributes(basin.shape)
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
class(basin.shape)
basin.shape@data
centroid<-SpatialPointsDataFrame(centroid,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
class(centroid)
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
centroid<-SpatialPointsDataFrame(centroid,data=data.frame(FeatureID=featureID,row.names=NULL),match.ID=FALSE)
catchments<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% seg,]
basin.shape<-gUnaryUnion(catchments)
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
coords(centroid)
centroid$coords
attr(centroid,"coords")
lat<-attr(centroid,"coords")$y
lat<-attr(centroid,"coords")[,"y"]
lat
long<-attr(centroid,"coords")[,"x"]
long
paste0(lat,", ",long)
rm(list=c("test","seg","featurID","lat","long"))
rm(list=c("test","seg","featureID","lat","long"))
rm(list=c("area","cumarea","basin","basin.shape")
)
rm(list=c("centroid","catchments","coord"))
getBasinfromComID<-function(featureID,dirname,output_type="kml") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
if (file.exists(paste0(dirname,"/",featureID)))
return(featureID)
### creates shapefiles and kml files of basin outline and streams & catchments it contains
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] >= 6) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] == 1) {
message("Please choose a larger stream or tributary")
return(NULL)
}
#else {
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
#collect all stream segments in upstream network
stream.line<-NHDFlow.line[NHDFlow.line$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export text file of comIDs, and param.json file with basin attributes
setwd(dirname)
write(segments, file = "COMID.txt", ncolumns = 1, sep = "")
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
write(param, file = "param.json", ncolumns=1,sep="")
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "UserDefinedBasin.kml", layer="UserDefinedBasin", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefil" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="UserDefinedBasin", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
return(featureID)
#}
} #end getBasinfromComID
getBasinfromLatLong<-function(lat,long,dirname,output_type="kml") {
#create spatialpoint object from coordinates (coordinates are listed in the order long, lat)
point<-SpatialPoints(matrix(data=c(long,lat),ncol=2,byrow=T), proj4string=CRS(proj4.NHD))
#get catchment that contains the point
featureID<-over(point,NHDCatch.shape)$FEATUREID
#call previous function to find basin from the NHDplus flowline or catchment feature
getBasinfromComID(featureID,dirname=dirname,output_type=output_type)
}
basedir<-"C:/ALR/GitHub/testing/basins"
temp<-6780817
basedir<-"C:/ALR/GitHub/testing/basins"
getBasinfromLatLong(42.414712,-72.629807,temp,output_type="both")
getBasinfromComID<-function(featureID,dirname,output_type="kml") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
setwd(dirname)
if (file.exists(param.json))
return(featureID)
### creates shapefiles and kml files of basin outline and streams & catchments it contains
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] >= 6) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] == 1) {
message("Please choose a larger stream or tributary")
return(NULL)
}
#else {
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
#collect all stream segments in upstream network
stream.line<-NHDFlow.line[NHDFlow.line$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "UserDefinedBasin.kml", layer="UserDefinedBasin", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefil" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="UserDefinedBasin", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write(segments, file = "COMID.txt", ncolumns = 1, sep = "")
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
write(param, file = "param.json", ncolumns=1,sep="")
return(param)
#}
} #end getBasinfromComID
temp<-6780817
setwd(paste0("C:/ALR/GitHub/testing/basins",temp))
setwd(paste0("C:/ALR/GitHub/testing/basins/",temp))
getBasinfromComID<-function(featureID,output_type="kml") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
if (file.exists(param.json))
return(featureID)
### creates shapefiles and kml files of basin outline and streams & catchments it contains
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] >= 6) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
if (plusflowlineVAA$StreamOrde[plusflowlineVAA$ComID==featureID] == 1) {
message("Please choose a larger stream or tributary")
return(NULL)
}
#else {
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
#collect all stream segments in upstream network
stream.line<-NHDFlow.line[NHDFlow.line$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-NHDCatch.shape[NHDCatch.shape$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "UserDefinedBasin.kml", layer="UserDefinedBasin", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefil" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="UserDefinedBasin", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write(segments, file = "COMID.txt", ncolumns = 1, sep = "")
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
write(param, file = "param.json", ncolumns=1,sep="")
return(param)
#}
} #end getBasinfromComID
getBasinfromLatLong(42.414712,-72.629807,output_type="both")
basedir<-"C:/ALR/GitHub/testing"
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
getBasinfromLatLong(42.414712,-72.629807,basedir,output_type="both")
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
getBasinfromLatLong(42.359146,-72.503593,basedir,output_type="shapefile")
toJSON(list(a=1,b="c"))
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
getBasinfromLatLong(42.359146,-72.503593,basedir,output_type="shapefile")
getBasinfromLatLong(42.359146,-72.503593,basedir,output_type="shapefile")
NHDCatch.shape<-lowCTCatch.shape
NHDFlow.line<-lowCTFlow.line
getBasinfromLatLong(42.328569,-72.582471,basedir,output_type="shapefile")
source("spatial_functions.R")
getBasinfromLatLong(42.328569,-72.582471,basedir,output_type="shapefile")
basedir<-"C:/ALR/GitHub/testing"
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
getBasinfromLatLong(42.328569,-72.582471,basedir,output_type="shapefile")
getBasinfromLatLong(42.335707,-72.573502,basedir,output_type="both")
setwd(C:\\ALR\\GitHub\\testing\\basins\\6780983)
setwd("C:\\ALR\\GitHub\\testing\\basins\\6780983")
read.csv("features.csv")
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
basedir<-"/home/ana/testing"
setwd(paste0(basedir,"/rscripts"))
basedir<-"C:/ALR/GitHub/testing"
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
args<-list(lat=42.542331,long=-72.544681,nickname="saw_mill")
{
if (!is.null(args$nickname))
getBasinfromLatLong(args$lat,args$long,basedir,nickname=args$nickname,output_type="both")
else
getBasinfromLatLong(args$lat,args$long,basedir,output_type="both")
}
setwd(paste0(basedir,"/rscripts"))
source("spatial_functions.R")
args<-list(lat=42.353628,long=-72.614912,nickname="saw_mill")
{
if (!is.null(args$nickname))
getBasinfromLatLong(args$lat,args$long,basedir,nickname=args$nickname,output_type="both")
else
getBasinfromLatLong(args$lat,args$long,basedir,output_type="both")
}
