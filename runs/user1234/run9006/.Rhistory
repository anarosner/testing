if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
print(paste("segments",segments))
#collect all stream segments in upstream network
stream.line<-flowlines[flowlines$COMID %in% segments,]
print("collect flowlines")
#collect all catchments around upstream network
catchment.shape<-catchments[catchments$FEATUREID %in% segments,]
print("collect catchments")
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
print("union")
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
print("centroid")
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "BasinOutline.kml", layer="BasinOutline", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefile" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="BasinOutline", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write.csv(segments, file="featureID.csv", row.names=FALSE)
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
if (nickname=="")
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
else
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long,nickname=nickname))
write(param, file = "param.json", ncolumns=1,sep="")
#    setwd(savedwd)
return(toJSON(list(featureID=featureID)))
} #end getBasinfromComID
getBasinfromLatLong(42.421400, -72.627059,basedir,output_type="both")
getBasinfromLatLong(42.421400, -72.627059,basedir,output_type="both")
getBasinfromComID<-function(featureID,HUC_8,basedir,output_type="kml",nickname="") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
#    savedwd<-getwd()
#if basin has already been delimited above that feature, return the ID and do not recreate file
setwd(paste0(basedir,"/basins/"))
print(paste("directory exists:",file.exists(as.character(featureID))))
if (file.exists(as.character(featureID))) {
#       setwd(savedwd)
print("repeat")
return(toJSON(list(featureID=featureID)))
}
#create directory for new basin
dir.create(as.character(featureID))
setwd(paste0(basedir,"/spatial_data/"))
#checks to see if selected main river, upstream of which would be a basin too big to work with
largefeatures<-read.csv("LargeFeatures.csv")
print(paste("is large feature:",featureID %in% largefeatures))
if (featureID %in% largefeatures) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
#read in flowlines for the huc this feature is in
#and the plusflow table, indicating feature connections
proj4.NHD<-"+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
flowlines<-readShapeLines(paste0(HUC_8,"Flowlines"),proj4string=CRS(proj4.NHD))
catchments<-readShapePoly(paste0(HUC_8,"Catchments"),proj4string=CRS(proj4.NHD))
plusflow<-read.csv("PlusFlow.csv")
print("read in flowlines")
setwd(paste0(basedir,"/basins/",featureID))
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
print(paste("segments",segments))
#collect all stream segments in upstream network
stream.line<-flowlines[flowlines$COMID %in% segments,]
print("collect flowlines")
#collect all catchments around upstream network
catchment.shape<-catchments[catchments$FEATUREID %in% segments,]
print("collect catchments")
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
print("union")
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
print("centroid")
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "BasinOutline.kml", layer="BasinOutline", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefile" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="BasinOutline", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write.csv(segments, file="featureID.csv", row.names=FALSE)
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
if (nickname=="")
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
else
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long,nickname=nickname))
write(param, file = "param.json", ncolumns=1,sep="")
#    setwd(savedwd)
return(toJSON(list(featureID=featureID)))
} #end getBasinfromComID
getBasinfromLatLong(42.421400, -72.627059,basedir,output_type="both")
getBasinfromLatLong(42.421400, -72.627059,basedir,output_type="both")
obj<-getBasinfromLatLong(42.421740, -72.648409,basedir,output_type="both")
obj
getBasinfromComID<-function(featureID,HUC_8,basedir,output_type="kml",nickname="") {
### defines basin from user-chosen
### NHDplus stream feature or catchment
### (stream feature's ComID == catchment's FeatureID)
#    savedwd<-getwd()
#if basin has already been delimited above that feature, return the ID and do not recreate file
setwd(paste0(basedir,"/basins/"))
#    print(paste("directory exists:",file.exists(as.character(featureID))))
if (file.exists(as.character(featureID))) {
#       setwd(savedwd)
print("repeat")
return(toJSON(list(featureID=featureID)))
}
#create directory for new basin
dir.create(as.character(featureID))
setwd(paste0(basedir,"/spatial_data/"))
#checks to see if selected main river, upstream of which would be a basin too big to work with
largefeatures<-read.csv("LargeFeatures.csv")
#    print(paste("is large feature:",featureID %in% largefeatures))
if (featureID %in% largefeatures) {
message("Please choose a smaller stream or tributary")
return(NULL)
}
#read in flowlines for the huc this feature is in
#and the plusflow table, indicating feature connections
proj4.NHD<-"+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
flowlines<-readShapeLines(paste0(HUC_8,"Flowlines"),proj4string=CRS(proj4.NHD))
catchments<-readShapePoly(paste0(HUC_8,"Catchments"),proj4string=CRS(proj4.NHD))
plusflow<-read.csv("PlusFlow.csv")
#    print("read in flowlines")
setwd(paste0(basedir,"/basins/",featureID))
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}
}
#    print(paste("segments",as.character(segments)))
#collect all stream segments in upstream network
stream.line<-flowlines[flowlines$COMID %in% segments,]
#    print("collect flowlines")
#collect all catchments around upstream network
catchment.shape<-catchments[catchments$FEATUREID %in% segments,]
#    print("collect catchments")
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#    print("union")
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#    print("centroid")
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "BasinOutline.kml", layer="BasinOutline", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefile" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="BasinOutline", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write.csv(segments, file="featureID.csv", row.names=FALSE)
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
if (nickname=="")
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
else
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long,nickname=nickname))
write(param, file = "param.json", ncolumns=1,sep="")
#    setwd(savedwd)
return(toJSON(list(featureID=featureID)))
} #end getBasinfromComID
getBasinfromLatLong<-function(lat,long,basedir,output_type="kml",nickname="") {
savedwd<-getwd()
#load huc 8 outlines
proj4.NHD<-"+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
setwd(paste0(basedir,"/spatial_data"))
HUC_8<-readShapePoly("HUC_8",proj4string=CRS(proj4.NHD))
#create spatialpoint object from coordinates (coordinates are listed in the order long, lat)
point<-SpatialPoints(matrix(data=c(long,lat),ncol=2,byrow=T), proj4string=CRS(proj4.NHD))
#get huc that contains the point
selected.huc<-over(point,HUC_8)$HUC_8
#    print(selected.huc)
#load catchments for that huc
catchments<-readShapePoly(paste0(selected.huc,"Catchments"),proj4string=CRS(proj4.NHD))
#    system.time(flowlines<-readShapeLines(paste0(selected.huc,"Flowlines"),proj4string=CRS(proj4.NHD)))
featureID<-over(point,catchments)$FEATUREID
#    print(featureID)
#call previous function to find basin from the NHDplus flowline or catchment feature
toreturn<-getBasinfromComID(featureID,HUC_8=as.character(selected.huc),basedir=basedir,output_type=output_type,nickname=nickname)
setwd(savedwd)
return(toreturn)
}
obj<-getBasinfromLatLong(42.417273, -72.641114,basedir,output_type="both")
system.time(obj<-getBasinfromLatLong(42.469329, -72.640127,basedir,output_type="both"))
args<-toJSON(list(lat=42.525652,long= -72.616781))
args
getwd
getwd()
setwd("C:/ALR/GitHub/testing/r/models")
source("delineate_basin.r")
source("delineate_basin.r")
args
names(args)
args<-list(lat=42.525652,long= -72.616781)
args
source("delineate_basin.r")
setwd("C:/ALR/GitHub/testing/r/models")
source("delineate_basin.r")
getwd()
source("delineate_basin.r")
setwd("C:/ALR/GitHub/testing/r/models")
source("delineate_basin.r")
rm(list=ls())
setwd("C:/ALR/GitHub/testing/r/models")
#!/usr/bin/env Rscript
print("starting basin delineation script")
savedwd<-getwd()
setwd("../..")
basedir<-getwd()
library(sp)
library(rgdal)
library(rgeos)
library(maptools)
library(rjson)
# args<-fromJSON( commandArgs(trailingOnly = TRUE) )
lat<-args$lat
long<-args$long
output_type<-"kml"
nickname<-""
args<-list(lat=42.525652,long= -72.616781)
# args<-fromJSON( commandArgs(trailingOnly = TRUE) )
lat<-args$lat
long<-args$long
output_type<-"kml"
nickname<-""
#load huc 8 outlines
proj4.NHD<-"+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
setwd(paste0(basedir,"/spatial_data"))
HUC_8<-readShapePoly("HUC_8",proj4string=CRS(proj4.NHD))
print("read hucs")
#create spatialpoint object from coordinates (coordinates are listed in the order long, lat)
point<-SpatialPoints(matrix(data=c(long,lat),ncol=2,byrow=T), proj4string=CRS(proj4.NHD))
#get huc that contains the point
selected.huc<-over(point,HUC_8)$HUC_8
#    print(selected.huc)
#load catchments for that huc
catchments<-readShapePoly(paste0(selected.huc,"Catchments"),proj4string=CRS(proj4.NHD))
print("read catchments")
featureID<-over(point,catchments)$FEATUREID
a<-over(point,catchments)
a@data
class(a)
a
class(a$FEATUREID)
over(point,catchments)
featureID<-over(point,catchments)$FEATUREID
featureID
#if basin has already been delimited above that feature, return the ID and do not recreate file
setwd(paste0(basedir,"/basins/"))
{
if (file.exists(as.character(featureID))) {
#       setwd(savedwd)
#    print("repeat")
message(toJSON(list(featureID=featureID)))
print(toJSON(list(featureID=featureID)))
}
else {
setwd(paste0(basedir,"/spatial_data/"))
#checks to see if selected main river, upstream of which would be a basin too big to work with
largefeatures<-read.csv("LargeFeatures.csv")
{
if (featureID %in% largefeatures) {
message("Please choose a smaller stream or tributary")
}
else {
#read in flowlines for the huc this feature is in
#and the plusflow table, indicating feature connections
flowlines<-readShapeLines(paste0(selected.huc,"Flowlines"),proj4string=CRS(proj4.NHD))
plusflow<-read.csv("PlusFlow.csv")
print("read flowlines")
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
{
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}}
}
#collect all stream segments in upstream network
stream.line<-flowlines[flowlines$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-catchments[catchments$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
#create directory for new basin
dir.create(as.character(featureID))
setwd(paste0(basedir,"/basins/",featureID))
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "BasinOutline.kml", layer="BasinOutline", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefile" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="BasinOutline", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
#export text file of comIDs, and param.json file with basin attributes
write.csv(segments, file="featureID.csv", row.names=FALSE)
area<-area<-sum(catchment.shape$AreaSqKM)
lat<-attr(centroid,"coords")[,"y"]
long<-attr(centroid,"coords")[,"x"]
{
if (nickname=="")
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long))
else
param<-toJSON(list(basinid=featureID,area=area,lat=lat,long=long,nickname=nickname))
}
write(param, file = "param.json", ncolumns=1,sep="")
print(toJSON(list(featureID=featureID)))
message(toJSON(list(featureID=featureID)))
}}#end else if feature isn't too large
}} #end else if dir doesn't exist
selected.huc
setwd(paste0(basedir,"/basins/"))
file.exists(as.character(featureID)
)
setwd(paste0(basedir,"/spatial_data/"))
largefeatures<-read.csv("LargeFeatures.csv")
featureID %in% largefeatures
#read in flowlines for the huc this feature is in
#and the plusflow table, indicating feature connections
flowlines<-readShapeLines(paste0(selected.huc,"Flowlines"),proj4string=CRS(proj4.NHD))
plusflow<-read.csv("PlusFlow.csv")
print("read flowlines")
#iteratively select all features upstream of user chosen feature
segments<-c() #list of flowline segments to save
queue<-c(featureID) #queue of flowline segments that need to be traced upstream
while (length(queue)>0) {
{
if(queue[1]==0) {
queue<-queue[-1] #discard 1st element in the queue if it's a zero
#in the NHDplus tables, features with FROMCOMID==0 have no inflowing tribs
}
else {
segments<-c(segments,queue[1]) #add 1st element to the saved segments
queue<-c(queue[-1],plusflow[plusflow$TOCOMID==queue[1],]$FROMCOMID) #remove 1st segment from the queue,
#add all segments that flow into it to the queue
}}
}
#collect all stream segments in upstream network
stream.line<-flowlines[flowlines$COMID %in% segments,]
#collect all catchments around upstream network
catchment.shape<-catchments[catchments$FEATUREID %in% segments,]
#dissolve border for basin outline
basin.shape<-gUnaryUnion(catchment.shape)
#get centroid to write to param file
centroid<-gCentroid(basin.shape, byid=FALSE, id = NULL)
#turn outline into spatial dataframe again to enable output as shapefile/kml
basin.shape<-SpatialPolygonsDataFrame(basin.shape,data=data.frame(StartFID=featureID,row.names=NULL),match.ID=FALSE)
getwd()
featureID
class(featureID)
as.character(featureID)
dir.create(as.character(featureID))
getwd()
setwd(paste0(basedir,"/basins/",featureID))
ls()
list.files()
#create directory for new basin
setwd(paste0(basedir,"/basins/"))
dir.create(as.character(featureID))
setwd(paste0(basedir,"/basins/",featureID))
#export spatial files of basin outline and flowlines
if (output_type=="kml" | output_type=="both") {
writeOGR(basin.shape,  "BasinOutline.kml", layer="BasinOutline", driver="KML",dataset_options=c("NameField=FEATUREID"))
writeOGR(stream.line,  "NHDplusFlowlines.kml", layer="NHDplusFlowlines", driver="KML",dataset_options=c("NameField=COMID","DescriptionField=GNIS_NAME"))
}
if (output_type=="shapefile" | output_type=="both") {
writeOGR(basin.shape,  ".", layer="BasinOutline", driver="ESRI Shapefile")
writeOGR(stream.line,  ".", layer="NHDplusFlowlines", driver="ESRI Shapefile")
}
getwd(paste0(basedir,"r/models"))
getwd(paste0(basedir,"/r/models"))
setwd(paste0(basedir,"r/models"))
paste0(basedir,"r/models")
paste0(basedir,"/r/models")
setwd(paste0(basedir,"/r/models"))
source("delineate_basin.R")
toJSON(list(lat=42.491991,long=-72.639097))
toJSON(list(lat=42.476167, long=-72.636693))
toJSON(list(lat=42.552182, long=-72.706560))
toJSON(list(userid=user1234,runid=run1001))
toJSON(list(userid="user1234",runid="run1001"))
getwd()
setwd("../..")
getwd()
setwd("./r/models")
rm(list=ls())
toJSON(list(userid="user1234",runid="run9006"))
testingids<-list(userid="user1234",runid="run9006")
source("WestbrookIPM.R")
testingid<-list(userid="user1234",runid="run9006")
source("WestbrookIPM.R")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
directory
rm(list=ls())
setwd("C:/ALR/GitHub/testing/r/models")
testingid<-list(userid="user1234",runid="run9006")
source("WestbrookIPM.R")
directory
ids$userid
ids$runid
testingid
ids
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
install.packages("arm")
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
rm(list=ls())
testingid<-list(runid="run9006")
setwd("C:/ALR/GitHub/testing/r/models")
source("WestbrookIPM.R")
library("reshape")
library("reshape2")
detach("package:reshape2")
detach("package:reshape")
library(reshape2)
getwd()
setwd("../../runs/user1234/run9006")
list.files()
load("StochProj.RData")
rm(list=ls())
load("StochProj.RData")
streamTemp
streamFlow
yearlyLamb
sumEggs
