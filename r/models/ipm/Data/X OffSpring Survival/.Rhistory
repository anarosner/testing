library(plyr)
library(rjags)
library(ggplot2)
library(abind)
#rjags::load.module("dic")
dMData$length[dMData$tagNumberCH=='1BF1FF6207' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF1FF6521' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF18CE7ED' & dMData$season == 2 & dMData$year == 2006] <- NA
dMData$length[dMData$tagNumberCH=='1BF20FF1B9' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='257C67CA48' ] <- NA
dMData$length[dMData$tagNumberCH=='1BF20EB7A4' & dMData$season == 4 & dMData$year == 2008] <- NA
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,year,season), summarise,
tempMean=mean(fullMeanT, na.rm=TRUE),
tempSd=sd(fullMeanT, na.rm=TRUE),
flowMean=mean(fullMeanD, na.rm=TRUE),
flowSd=sd(fullMeanD, na.rm=TRUE)
)
############# To get rid of NA Rivers
stdBySeasonRiver<-stdBySeasonRiver[!is.na(stdBySeasonRiver$riverN),]
stdBySeasonRiver
library(plyr)
library(rjags)
library(ggplot2)
library(abind)
#rjags::load.module("dic")
dMData$length[dMData$tagNumberCH=='1BF1FF6207' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF1FF6521' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF18CE7ED' & dMData$season == 2 & dMData$year == 2006] <- NA
dMData$length[dMData$tagNumberCH=='1BF20FF1B9' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='257C67CA48' ] <- NA
dMData$length[dMData$tagNumberCH=='1BF20EB7A4' & dMData$season == 4 & dMData$year == 2008] <- NA
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,year,season), summarise,
tempMean=mean(fullMeanT, na.rm=TRUE),
flowMean=mean(fullMeanD, na.rm=TRUE)
)
############# To get rid of NA Rivers
stdBySeasonRiver<-stdBySeasonRiver[!is.na(stdBySeasonRiver$riverN),]
stdBySeasonRiver
library(plyr)
library(rjags)
library(ggplot2)
library(abind)
#rjags::load.module("dic")
dMData$length[dMData$tagNumberCH=='1BF1FF6207' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF1FF6521' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF18CE7ED' & dMData$season == 2 & dMData$year == 2006] <- NA
dMData$length[dMData$tagNumberCH=='1BF20FF1B9' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='257C67CA48' ] <- NA
dMData$length[dMData$tagNumberCH=='1BF20EB7A4' & dMData$season == 4 & dMData$year == 2008] <- NA
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,year,season), summarise,
length)
############# To get rid of NA Rivers
stdBySeasonRiver<-stdBySeasonRiver[!is.na(stdBySeasonRiver$riverN),]
stdBySeasonRiver
library(plyr)
library(rjags)
library(ggplot2)
library(abind)
#rjags::load.module("dic")
dMData$length[dMData$tagNumberCH=='1BF1FF6207' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF1FF6521' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF18CE7ED' & dMData$season == 2 & dMData$year == 2006] <- NA
dMData$length[dMData$tagNumberCH=='1BF20FF1B9' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='257C67CA48' ] <- NA
dMData$length[dMData$tagNumberCH=='1BF20EB7A4' & dMData$season == 4 & dMData$year == 2008] <- NA
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,year,season), summarise,
length)
stdBySeasonRiver
stdBySeasonRiver[1,]
dMData$length
dMData
View(dMData)
View(dMData)
library(plyr)
library(rjags)
library(ggplot2)
library(abind)
#rjags::load.module("dic")
dMData$length[dMData$tagNumberCH=='1BF1FF6207' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF1FF6521' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='1BF18CE7ED' & dMData$season == 2 & dMData$year == 2006] <- NA
dMData$length[dMData$tagNumberCH=='1BF20FF1B9' & dMData$season == 3 & dMData$year == 2005] <- NA
dMData$length[dMData$tagNumberCH=='257C67CA48' ] <- NA
dMData$length[dMData$tagNumberCH=='1BF20EB7A4' & dMData$season == 4 & dMData$year == 2008] <- NA
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,season), summarise,
lengthMean=mean(length, na.rm=TRUE),
lengthSd=sd(length, na.rm=TRUE),
lengthLo = quantile(length,c(0.025), na.rm=TRUE),
lengthHi = quantile(length,c(0.975), na.rm=TRUE),
tempMean=mean(fullMeanT, na.rm=TRUE),
tempMeanP=mean(temperatureForP, na.rm=TRUE),
tempSd=sd(fullMeanT, na.rm=TRUE),
tempSdP=sd(temperatureForP, na.rm=TRUE),
tempLo = quantile(fullMeanT,c(0.025), na.rm=TRUE),
tempHi = quantile(fullMeanT,c(0.975), na.rm=TRUE),
flowMean=mean(fullMeanD, na.rm=TRUE),
flowSd=sd(fullMeanD, na.rm=TRUE),
dischMeanP=mean(dischargeForP,na.rm=T),
dischSdP=sd(dischargeForP,na.rm=T),
flowLo = quantile(fullMeanD,c(0.025), na.rm=TRUE),
flowHi = quantile(fullMeanD,c(0.975), na.rm=TRUE) )
############# To get rid of NA Rivers
stdBySeasonRiver<-stdBySeasonRiver[!is.na(stdBySeasonRiver$riverN),]
#####################################################################
stdBySeason <- ddply( dMData, .(season), summarise,
lengthMean=mean(length, na.rm=TRUE),
lengthSd=sd(length, na.rm=TRUE),
lengthLo = quantile(length,c(0.025), na.rm=TRUE),
lengthHi = quantile(length,c(0.975), na.rm=TRUE),
tempMean=mean(fullMeanT, na.rm=TRUE),
tempMeanP=mean(temperatureForP, na.rm=TRUE),
tempSd=sd(fullMeanT, na.rm=TRUE),
tempSdP=sd(temperatureForP, na.rm=TRUE),
tempLo = quantile(fullMeanT,c(0.025), na.rm=TRUE),
tempHi = quantile(fullMeanT,c(0.975), na.rm=TRUE),
flowMean=mean(fullMeanD, na.rm=TRUE),
flowSd=sd(fullMeanD, na.rm=TRUE),
dischMeanP=mean(dischargeForP,na.rm=T),
dischSdP=sd(dischargeForP,na.rm=T),
flowLo = quantile(fullMeanD,c(0.025), na.rm=TRUE),
flowHi = quantile(fullMeanD,c(0.975), na.rm=TRUE) )
# standardize by river  - for age0 fall lengths
stdByRiver <- ddply( dMData, .(riverOrdered,riverN), summarise,
lengthSd0 = sd(subset( length, age == 0 & season == 3 ), na.rm=TRUE),
lengthMean0 = mean(subset( length, age == 0 & season == 3 ), na.rm=TRUE) )
stdByRiver <- stdByRiver[!is.na(stdByRiver$riverN),]
stdByRiver$river <- as.numeric(stdByRiver$riverOrdered)
#stdBySeasonRiver<-rbind(stdBySeasonRiver,c('zRiv1','0',rep(NA,ncol(stdBySeasonRiver)-2)))
#####
# fdDATA is flood and drought frequencies and durations
fdDATA$year <- as.numeric( fdDATA$year )
fdDATA$year2 <- fdDATA$year
fdDATA$year <- fdDATA$year-min(fdDATA$year) + 1
floodDur <- matrix(0,max(fdDATA$season),max(fdDATA$year))
droughtDur <- matrix(0,max(fdDATA$season),max(fdDATA$year))
floodFreq <- matrix(0,max(fdDATA$season),max(fdDATA$year))
for ( i in 1:nrow(fdDATA) ){
floodDur[fdDATA$season[i],fdDATA$year[i]] <- fdDATA$floodDur[i]
droughtDur[fdDATA$season[i],fdDATA$year[i]] <- fdDATA$droughtDur[i]
floodFreq[fdDATA$season[i],fdDATA$year[i]] <- fdDATA$floodFreq[i]
}
#####
# function to add dummy rows and columns for zRiv=1
addRowColMeans <- function(m){
m <- cbind( rowMeans(m),m )
m <- rbind( colMeans(m),m )
return ( m )
}
# function to add dummy columns for zRiv=1
addColMeans <- function(m){
m <- cbind( rowMeans(m),m )
return ( m )
}
tempForN<- array(NA,dim=c(4,5,max(dMData$year-min(dMData$year) + 1)))
for(s in 1:4){
for(y in 1:max(dMData$year-min(dMData$year) + 1)){
tempForN[s,1,y]<-(stdBySeason$tempMean[s]- stdBySeason$tempMean[s] ) / stdBySeason$tempSd[ s ]
for(r in 1:4){
tempForN[s,r+1,y]<-(mean(dMData$fullMeanT[dMData$season==s&as.numeric(dMData$riverOrdered)==r&(dMData$year-min(dMData$year) + 1)==y],na.rm=T)
- stdBySeason$tempMean[ s] ) / stdBySeason$tempSd[ s ]
if(tempForN[s,r+1,y]=='NaN')tempForN[s,r+1,y]<-(stdBySeason$tempMean[s]- stdBySeason$tempMean[ s] ) / stdBySeason$tempSd[ s ]
}
}
}
flowForN<- array(NA,dim=c(4,5,max(dMData$year-min(dMData$year) + 1)))
for(s in 1:4){
for(y in 1:max(dMData$year-min(dMData$year) + 1)){
flowForN[s,1,y]<-(stdBySeason$flowMean[s]- stdBySeason$flowMean[s] ) / stdBySeason$flowSd[s]
for(r in 1:4){
flowForN[s,r+1,y]<-(mean(dMData$fullMeanD[dMData$season==s&as.numeric(dMData$riverOrdered)==r&(dMData$year-min(dMData$year) + 1)==y],na.rm=T)
- stdBySeason$flowMean[s] ) / stdBySeason$flowSd[s]
if(flowForN[s,r+1,y]=='NaN')flowForN[s,r+1,y]<-(stdBySeason$flowMean[s]- stdBySeason$flowMean[s] ) / stdBySeason$flowSd[s]
}
}
}
############ Predictors that are in a matrix have season in rows and river in columns
d <- within(
data = list(),
expr = {
encDATA = as.numeric(dMData$enc) #$msEnc
riverDATA = as.numeric(dMData$riverOrdered) #-3
nRivers = length(unique(dMData$riverN))-1 #may need to add one for unobs
lengthDATA = dMData$length
availableDATA = dMData$available01
ind = as.numeric(dMData$tagNumberCH)
# For standardizing length
lengthMean = addColMeans( matrix(stdBySeasonRiver$lengthMean,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
lengthSd =   addColMeans( matrix(stdBySeasonRiver$lengthSd,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
lengthMean0 = stdByRiver$lengthMean0
lengthSd0 = stdByRiver$lengthSd0
# environmental covariates pertaining to intervals.  These are
# covariates of growth and survival
# For standardizing env predictors of growth and surv
tempMean = addColMeans( matrix(stdBySeasonRiver$tempMean,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
tempSd =   addColMeans( matrix(stdBySeasonRiver$tempSd,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
flowMean = addColMeans( matrix(stdBySeasonRiver$flowMean,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
flowSd =   addColMeans( matrix(stdBySeasonRiver$flowSd,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
## Predictors of phi for correcting N1 where countForN ==0
tempForN = tempForN
flowForN = flowForN
# not standardizing by season,river because on NAs in river
tempDATA = ( as.numeric(dMData$fullMeanT) - stdBySeason$tempMean[ as.numeric(dMData$season)] ) / stdBySeason$tempSd[ as.numeric(dMData$season) ]
flowDATA = ( as.numeric(dMData$fullMeanD) - stdBySeason$flowMean[ as.numeric(dMData$season)] ) / stdBySeason$flowSd[ as.numeric(dMData$season) ]
# emPermNA, used to censor likelihood for permanent emigrants
# 1 on line before last observation with subsequent bottom of the study site antenna hit. 0's before and after if em, NAs otherwise
# trying emPerm without the NAs
emPermDATA = dMData$emPerm
intervalDays = as.numeric(dMData$fullMeanIntLen )
# Environmental covariates for p
flowP = as.numeric(dMData$dischargeForP)
temperatureP = as.numeric(dMData$temperatureForP)
#For standardizing env predictors of p
flowMeanP = addRowColMeans( matrix(stdBySeasonRiver$dischMeanP,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
flowSdP = addRowColMeans( matrix(stdBySeasonRiver$dischSdP,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
tempMeanP = addRowColMeans( matrix(stdBySeasonRiver$tempMeanP,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
tempSdP = addRowColMeans( matrix(stdBySeasonRiver$tempSdP,nrow=length(unique(dMData$season)),ncol=length(unique(as.numeric(dMData$riverN)-0))-1) )
# , growthSd = sd(((dMData$lagLength - dMData$length)/(as.numeric(dMData$intervalLength)))*365/4, na.rm=TRUE)
######## NEVER!!!! #########  gr = (dMData$lagLength - dMData$length)/(as.numeric(dMData$intervalLength))
# indexing of the input and state vectors
year = dMData$year-min(dMData$year) + 1
nYears = max(dMData$year)-min(dMData$year)+1
season = as.numeric(as.character(dMData$season))
nAllRows = length(dMData[,1])
nFirstObsRows = evalList$nFirstObsRows
firstObsRows = evalList$firstObsRows
nOcc = length(unique(dMData$sampleNum))
occ = dMData$sampleNum-min(dMData$sampleNum)-1
nEvalRows = evalList$nEvalRows # rows that will matter if we start using JS, and
evalRows = evalList$evalRows   # that matter now for the growth model
lastPossibleRows = subset( 1:nrow(dMData),dMData$lastAIS==dMData$ageInSamples ) # need to put this in makedMData
nLastPossibleRows = evalList$nFirstObsRows
lastObsRows = evalList$lastObsRows
nLastObsRows = evalList$nLastObsRows
lastRows = lastPossibleRows
nLastRows = nLastPossibleRows
nOut = evalList$nEvalRows # evalRows to output for each trace
#create variables that hold information on counts - data held in statsForN (made in makeDMData.R - based on pheno2Long, so has all cohorts. need to throw away years before dMData's first cohort)
minYear <- min(dMData$year)
firstYearIndex <- minYear-statsForN$minYear + 1
# countForN has dummy river 1 in it
countForN <- statsForN$countForN[,firstYearIndex:dim(statsForN$countForN)[2],]
meanForN <- statsForN$meanForN
sdForN <- statsForN$sdForN
#  dMDataF <- dMData[ dMData$first == dMData$sampleNum, ]
#  nTagged1 <- table(dMDataF$season,dMDataF$year,dMDataF$riverOrdered)
#Fill in random #s for zRiv=1
#  nTagged <- abind(matrix(round(runif(4*nYears,10,50)), nrow=4,ncol=nYears),nTagged1)
floodDurDATA <- floodDur
droughtDurDATA <- droughtDur
floodFreqDATA <- floodFreq
}
)
d
help(pasate)
help(paste)
#clear everything, just to be safe
rm(list=ls(all=TRUE))
library(ggplot2)
library(plyr)
library(reshape)
library(arm)
library(lme4)
setwd('~/Projects/Current/Westbrook/Brook Trout/Data/Offspring Survival')
#load('C:/PITTAGMAIN/CMR Analyses/Hierach_Bugs/allSpp/dMDataOutBKT2002_2011.RData')
load("~/Projects/Current/Westbrook/Brook Trout/Data/Estimation Models/dMDataOutBKT2002_2011.RData")
####################################################
# make data frame of p data
#load( "c:/PITTAGMAIN/CMR Analyses/Hierach_Bugs/allSpp/MSRiver2/output-39ac22712d23-MSRiver/outMSRiver.RData")
#load("~/Projects/Current/Westbrook/Brook Trout/Data/MSRiver2/output-39ac22712d23-MSRiver/outMSRiver.RData")
load("~/Projects/Current/Westbrook/Brook Trout/Data/Input Data/outMSRiver.RData")
# minimum and maximum sizes
minsize= 30;
maxsize=260;
L= minsize;
U= maxsize;
#Do not change. This defines the number of sub-"adult" stages, not yet setup to accomodate more
n <- n.big.matrix <- 100   #size of demographic matrix
# boundary points b and mesh points y
b = L+c(0:n)*(U-L)/n;
y = 0.5*(b[1:n]+b[2:(n+1)]);
# step size for midpoint rule
h = y[2]-y[1]
p <- adply(invlogit(out$pBeta),.margins= c(1,2,3),mean)
names(p) <- c('season','year2','river2','p')
p <- p[p$river2 != 1,] ; p$river2 <- as.numeric(as.character(p$river2)) - 1
p$river <- 'WEST BROOK'
p$river[p$river2 == 2] <- 'WB JIMMY'
p$river[p$river2 == 3] <- 'WB MITCHELL'
p$river[p$river2 == 4] <- 'WB OBEAR'
p$year <- as.numeric(as.character(p$year2)) + d$minYear - 1
p$season <- as.numeric(as.character(p$season))
p$riverOrdered <- factor(p$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
####################################################
####################################################
# create data frame of counts
dMData$riverOrdered <- factor(dMData$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
dMData$numEggs  <- ((0.00187 * dMData$length ^ 2.19) )# * plogis(dMData$length, 75, 1))#*.8
dMData$numEggs[which(dMData$numEggs%in%NA)] <- 0
#YOYAdBoundary <- 80 # make year-specific from dMData?
#YOY <- dMData[which(dMData$age==0),]
#countYOY <- melt( ftable(dMData[dMData$enc == 1 & dMData$length <  YOYAdBoundary ,c('season','year','riverOrdered')]) )
countYOY <- melt( ftable(dMData[dMData$enc == 1 & dMData$age ==  0 ,c('season','year','riverOrdered')]) )
countAd <-  melt( ftable(dMData[dMData$enc == 1 & dMData$age != 0 ,c('season','year','riverOrdered')]) )
#sumEggs <- ddply(dMData[dMData$enc == 1 & dMData$length >= YOYAdBoundary,c('season','year','riverOrdered','numEggs')], c('season','year','riverOrdered'), summarise,sumEggs=sum(numEggs) )
sumEggs <- ddply(dMData[dMData$enc == 1 & dMData$age != 0,c('season','year','riverOrdered','numEggs')], c('season','year','riverOrdered'), summarise,sumEggs=sum(numEggs) )
sumEggs$sumEggs <- sumEggs$sumEggs * 0.5 #females
count <- merge(x=countAd, y=countYOY, by=c('value.season','value.year','value.riverOrdered'), all.x=T)
names(count ) <- c('season','year','river','countAd','countYOY')
count <- merge(x=count, y=sumEggs, by.x=c('season','year','river'),by.y=c('season','year','riverOrdered'), all.x=T)
count$year <- as.numeric(as.character(count$year))
count$season <- as.numeric(as.character(count$season))
count$riverOrdered <- factor(count$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
####################################################
# merge in p data
countP <- merge( x=count, y=p[,c('season','year','riverOrdered','p')], by=c('season','year','riverOrdered'), all.x=T)
# countP$pAd <- countP$p
# countP <- merge( x=countP, y=p[,c('season','year','riverOrdered','p')],
#                  by.x=c('season','yearYOY','riverOrdered'),
#                  by.y=c('season','year','riverOrdered'),all.x=T)
#
# countP$pYOY <- countP$p.y
# countP$p.x <- NULL ; countP$p.y <- NULL
# countP <- countP[order(countP$river,countP$year),]
countP$countYOY[which(countP$countYOY==0)] <- NA #makes the zero a very small number
countP$countAdAdj <- countP$countAd/countP$p
countP$countYOYAdj <- countP$countYOY/countP$p
countP$sumEggsAdj <- countP$sumEggs/countP$p
count2 <- countP[countP$season == 3 & countP$year>2002,]
count2 <- count2[order(count2$river,count2$year),]
count2$YOYLag <- c(count2$countYOY[2:nrow(count2)],NA)
count2$YOYLagAdj <- c(count2$countYOYAdj[2:nrow(count2)],NA)
count2$yearYOY <- count2$year+1
####################################################
# merge in env data
# means for standardizing
#####################################################################
stdBySeasonRiver <- ddply( dMData, .(riverOrdered,riverN,season), summarise,
lengthMean=mean(length, na.rm=TRUE),
lengthSd=sd(length, na.rm=TRUE),
lengthLo = quantile(length,c(0.025), na.rm=TRUE),
lengthHi = quantile(length,c(0.975), na.rm=TRUE),
tempMean=mean(fullMeanT, na.rm=TRUE),
tempMeanP=mean(temperatureForP, na.rm=TRUE),
tempSd=sd(fullMeanT, na.rm=TRUE),
tempSdP=sd(temperatureForP, na.rm=TRUE),
tempLo = quantile(fullMeanT,c(0.025), na.rm=TRUE),
tempHi = quantile(fullMeanT,c(0.975), na.rm=TRUE),
flowMean=mean(fullMeanD, na.rm=TRUE),
flowSd=sd(fullMeanD, na.rm=TRUE),
dischMeanP=mean(dischargeForP,na.rm=T),
dischSdP=sd(dischargeForP,na.rm=T),
flowLo = quantile(fullMeanD,c(0.025), na.rm=TRUE),
flowHi = quantile(fullMeanD,c(0.975), na.rm=TRUE) )
############# To get rid of NA Rivers
stdBySeasonRiver<-stdBySeasonRiver[!is.na(stdBySeasonRiver$riverN),]
tempForN<- array(NA,dim=c(4,5,max(dMData$year-min(dMData$year) + 1)))
for(s in 1:4){
for(ye in 1:max(dMData$year-min(dMData$year) + 1)){
tempForN[s,1,ye]<-0
for(r in 1:4){
tempForN[s,r+1,ye]<-(mean(dMData$fullMeanT[dMData$season==s&as.numeric(dMData$riverOrdered)==r&(dMData$year-min(dMData$year) + 1)==ye],na.rm=T)
- stdBySeasonRiver$tempMean[ 4*(r-1)+s ] ) / stdBySeasonRiver$tempSd[ 4*(r-1)+s ]
if(tempForN[s,r+1,ye]=='NaN')tempForN[s,r+1,ye]<-(stdBySeasonRiver$tempMean[4*(r-1)+s]- stdBySeasonRiver$tempMean[ 4*(r-1)+s] ) / stdBySeasonRiver$tempSd[ 4*(r-1)+s ]
}
}
}
flowForN<- array(NA,dim=c(4,5,max(dMData$year-min(dMData$year) + 1)))
for(s in 1:4){
for(ye in 1:max(dMData$year-min(dMData$year) + 1)){
flowForN[s,1,ye]<-0
for(r in 1:4){
flowForN[s,r+1,ye]<-(mean(dMData$fullMeanD[dMData$season==s&as.numeric(dMData$riverOrdered)==r&(dMData$year-min(dMData$year) + 1)==ye],na.rm=T)
- stdBySeasonRiver$flowMean[4*(r-1)+s] ) / stdBySeasonRiver$flowSd[4*(r-1)+s]
if(flowForN[s,r+1,ye]=='NaN')flowForN[s,r+1,ye]<-(stdBySeasonRiver$flowMean[4*(r-1)+s]- stdBySeasonRiver$flowMean[4*(r-1)+s] ) / stdBySeasonRiver$flowSd[4*(r-1)+s]
}
}
}
env <- cbind(melt(flowForN), melt(tempForN))
env <- env[,-(5:7)]
names(env) <- c('season','river2','year2','stdF','stdT')
env$year <- env$year2 + d$minYear - 1
env$yearYOY <- env$year + 1
env <- env[env$river2 != 1,] ; env$river2 <- as.numeric(as.character(env$river2)) - 1
env$river <- 'WEST BROOK'
env$river[env$river2 == 2] <- 'WB JIMMY'
env$river[env$river2 == 3] <- 'WB MITCHELL'
env$river[env$river2 == 4] <- 'WB OBEAR'
env$riverOrdered <- factor(env$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
env <- env[order(env$riverOrdered,env$year,env$season),]
env$stdFLag1 <- c(NA,env$stdF[1:(nrow(env)-1)])
env$stdFLag2 <- c(NA,NA,env$stdF[1:(nrow(env)-2)])
env$stdFLag3 <- c(NA,NA,NA,env$stdF[1:(nrow(env)-3)])
env$stdFLag4 <- c(NA,NA,NA,NA,env$stdF[1:(nrow(env)-4)])
env$stdTLag1 <- c(NA,env$stdT[1:(nrow(env)-1)])
env$stdTLag2 <- c(NA,NA,env$stdT[1:(nrow(env)-2)])
env$stdTLag3 <- c(NA,NA,NA,env$stdT[1:(nrow(env)-3)])
env$stdTLag4 <- c(NA,NA,NA,NA,env$stdT[1:(nrow(env)-4)])
###Use this once it has been replaced in the callMSRiver file
# env <- cbind(melt(d$flowForN), melt(d$tempForN))
# env <- env[,-(5:7)]
# names(env) <- c('season','river2','year2','stdF','stdT')
#
# env$yearAd <- env$year2 + d$minYear - 1
# env$yearYOY <- env$yearAd + 1
#
# env <- env[env$river2 != 1,] ; env$river2 <- as.numeric(as.character(env$river2)) - 1
# env$river <- 'WEST BROOK'
# env$river[env$river2 == 2] <- 'WB JIMMY'
# env$river[env$river2 == 3] <- 'WB MITCHELL'
# env$river[env$river2 == 4] <- 'WB OBEAR'
#
# env$riverOrdered <- factor(env$river,levels=c('WEST BROOK','WB JIMMY','WB MITCHELL','WB OBEAR'), ordered=T)
#
# env <- env[order(env$riverOrdered,env$yearYOY,env$season),]
#
# env$stdFLag1 <- c(NA,env$stdF[1:(nrow(env)-1)])
# env$stdFLag2 <- c(NA,NA,env$stdF[1:(nrow(env)-2)])
# env$stdFLag3 <- c(NA,NA,NA,env$stdF[1:(nrow(env)-3)])
# env$stdFLag4 <- c(NA,NA,NA,NA,env$stdF[1:(nrow(env)-4)])
# env$stdTLag1 <- c(NA,env$stdT[1:(nrow(env)-1)])
# env$stdTLag2 <- c(NA,NA,env$stdT[1:(nrow(env)-2)])
# env$stdTLag3 <- c(NA,NA,NA,env$stdT[1:(nrow(env)-3)])
# env$stdTLag4 <- c(NA,NA,NA,NA,env$stdT[1:(nrow(env)-4)])
countPE <- merge(x=count2, y=env[,c('season','yearYOY','year','riverOrdered','stdF','stdT','stdFLag1','stdTLag1','stdFLag2','stdTLag2','stdFLag3','stdTLag3','stdFLag4','stdTLag4')],
by.x=c('season','yearYOY','riverOrdered'), by.y=c('season','year','riverOrdered'),all.x=T)
countPE <- countPE[-((dim(countPE)[1]-3):(dim(countPE)[1])),] #THis removes the last year
countPE <- countPE[-c(33:36),]
########################################
# run a glm on the data
countPE$stdFLag12 <- countPE$stdFLag1^2
countPE$stdFLag22 <- countPE$stdFLag2^2
countPE$stdFLag32 <- countPE$stdFLag3^2
countPE$stdFLag42 <- countPE$stdFLag4^2
countPE$stdTLag12 <- countPE$stdTLag1^2
countPE$stdTLag22 <- countPE$stdTLag2^2
countPE$stdTLag32 <- countPE$stdTLag3^2
countPE$stdTLag42 <- countPE$stdTLag4^2
countPE$survJuv <- countPE$YOYLagAdj/countPE$sumEggsAdj
countPE$survJuv[which(countPE$survJuv%in%NA)] <- 0.012359118
countPE$logitsurvJuv <- log(countPE$survJuv/(1-countPE$survJuv))
countPE$arsinsqrt  <- asin(sqrt(countPE$survJuv))
countPE$yearYOY <- as.factor(countPE$yearYOY)
# countPE$survJuv[29] <- NA
# countPE$logitsurvJuv[29] <- NA
mod <- glm( (logitsurvJuv) ~
0 + river *     (stdFLag1 +
stdTLag1 +
stdFLag2 +
stdTLag2 +
stdFLag1 *
stdTLag1  +
stdFLag2 *
stdTLag2
) -
stdFLag1 -
stdTLag1 -
stdFLag2 -
stdTLag2 -
stdFLag1 *
stdTLag1  -
stdFLag2 *
stdTLag2
, family=gaussian,
data=countPE)#[countPE$river %in% 'WEST BROOK',]  )
summary(mod)
plot(invlogit(mod$fitted.values),invlogit(mod$data$logitsurvJuv))
plot(mod)
geom_text(aes(label=yearYOY)) +
facet_wrap(~river,scales='free')
ggplot(countPE, aes(x=(year),y=(countAdAdj))) +
geom_line(size=2)+
geom_text(aes(label=year)) +
facet_wrap(~river,scales='free')
ggplot(countPE, aes(x=(year),y=(countAdAdj+countYOYAdj))) +
geom_line(size=2)+
geom_text(aes(label=year)) +
facet_wrap(~river,scales='free')
ggplot(countPE, aes(x=(stdFLag4),y=(stdTLag4))) +
geom_point(size=2)+
geom_text(aes(label=yearYOY)) +
facet_wrap(~river,scales='free') +
geom_smooth(method = "lm", formula = y ~ poly(x,2), colour = "red")
#outSj <- mod$coefficients
outSj <- array(NA,c(4,7))
for (r in 1:4){
outSj[r,] <- mod$coefficients[c(1,5,9,13,17,21,25)+(r-1)]
}
# need to check that all the years line up and that no years are missing
sJ <- abind(countPE$yearYOY,countPE$river,countPE$survJuv,along=2)
sJ <- sJ[-c(33:36),]
sJriver <- array(0,c(4,8))
for (river in 1:4){
sJriver[river,] <- sJ[which(sJ[,2]==river),3]
}
save.image("~/Projects/Current/Westbrook/Brook Trout/Data/Input Data/outSjSurv.RData")
stdBySeasonRiver
stdBySeasonRiver$tempMean
